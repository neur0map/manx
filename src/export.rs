use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use crate::client::{SearchResult, Documentation, DocSection};

pub enum ExportFormat {
    Markdown,
    Json,
}

impl ExportFormat {
    pub fn from_path(path: &Path) -> Self {
        match path.extension().and_then(|s| s.to_str()) {
            Some("json") => ExportFormat::Json,
            _ => ExportFormat::Markdown,
        }
    }
}

pub struct Exporter;

impl Exporter {
    pub fn export_search_results(
        results: &[SearchResult],
        path: &Path,
    ) -> Result<()> {
        let format = ExportFormat::from_path(path);
        
        let content = match format {
            ExportFormat::Json => serde_json::to_string_pretty(results)?,
            ExportFormat::Markdown => Self::search_results_to_markdown(results),
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    pub fn export_documentation(
        doc: &Documentation,
        path: &Path,
    ) -> Result<()> {
        let format = ExportFormat::from_path(path);
        
        let content = match format {
            ExportFormat::Json => serde_json::to_string_pretty(doc)?,
            ExportFormat::Markdown => Self::documentation_to_markdown(doc),
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    fn search_results_to_markdown(results: &[SearchResult]) -> String {
        let mut md = String::new();
        
        md.push_str("# Search Results\n\n");
        md.push_str(&format!("Found {} results\n\n", results.len()));
        
        for (idx, result) in results.iter().enumerate() {
            md.push_str(&format!("## {}. {}\n\n", idx + 1, result.title));
            md.push_str(&format!("- **Library**: {}\n", result.library));
            md.push_str(&format!("- **ID**: `{}`\n", result.id));
            
            if let Some(url) = &result.url {
                md.push_str(&format!("- **URL**: [{}]({})\n", url, url));
            }
            
            md.push_str(&format!("- **Relevance**: {:.2}\n\n", result.relevance_score));
            
            md.push_str("### Excerpt\n\n");
            md.push_str(&result.excerpt);
            md.push_str("\n\n---\n\n");
        }
        
        md
    }
    
    fn documentation_to_markdown(doc: &Documentation) -> String {
        let mut md = String::new();
        
        // Header
        md.push_str(&format!("# {} Documentation\n\n", doc.library.name));
        
        if let Some(version) = &doc.library.version {
            md.push_str(&format!("**Version**: {}\n\n", version));
        }
        
        if let Some(desc) = &doc.library.description {
            md.push_str(&format!("> {}\n\n", desc));
        }
        
        // Table of Contents
        if doc.sections.len() > 1 {
            md.push_str("## Table of Contents\n\n");
            for section in &doc.sections {
                let anchor = section.title.to_lowercase().replace(' ', "-");
                md.push_str(&format!("- [{}](#{})\n", section.title, anchor));
            }
            md.push_str("\n");
        }
        
        // Sections
        for section in &doc.sections {
            md.push_str(&format!("## {}\n\n", section.title));
            
            if let Some(url) = &section.url {
                md.push_str(&format!("*Source: [{}]({})*\n\n", url, url));
            }
            
            md.push_str(&section.content);
            md.push_str("\n\n");
            
            // Code examples
            for example in &section.code_examples {
                if let Some(desc) = &example.description {
                    md.push_str(&format!("### {}\n\n", desc));
                }
                
                md.push_str(&format!("```{}\n", example.language));
                md.push_str(&example.code);
                if !example.code.ends_with('\n') {
                    md.push('\n');
                }
                md.push_str("```\n\n");
            }
        }
        
        // Footer
        md.push_str("---\n\n");
        md.push_str("*Generated by [Manx](https://github.com/yourusername/manx) - ");
        md.push_str("Powered by Context7 MCP*\n");
        
        md
    }
    
    pub fn export_snippet(
        section: &DocSection,
        path: &Path,
    ) -> Result<()> {
        let format = ExportFormat::from_path(path);
        
        let content = match format {
            ExportFormat::Json => serde_json::to_string_pretty(section)?,
            ExportFormat::Markdown => Self::snippet_to_markdown(section),
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    fn snippet_to_markdown(section: &DocSection) -> String {
        let mut md = String::new();
        
        md.push_str(&format!("# {}\n\n", section.title));
        
        if let Some(url) = &section.url {
            md.push_str(&format!("*Source: [{}]({})*\n\n", url, url));
        }
        
        md.push_str(&section.content);
        md.push_str("\n\n");
        
        for example in &section.code_examples {
            if let Some(desc) = &example.description {
                md.push_str(&format!("## {}\n\n", desc));
            }
            
            md.push_str(&format!("```{}\n", example.language));
            md.push_str(&example.code);
            if !example.code.ends_with('\n') {
                md.push('\n');
            }
            md.push_str("```\n\n");
        }
        
        md
    }
}