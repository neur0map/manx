use anyhow::{Context, Result};
use std::fs;
use std::path::Path;
use crate::client::{SearchResult, Documentation};

pub enum ExportFormat {
    Markdown,
    Json,
}

impl ExportFormat {
    pub fn from_path(path: &Path) -> Self {
        match path.extension().and_then(|s| s.to_str()) {
            Some("json") => ExportFormat::Json,
            _ => ExportFormat::Markdown,
        }
    }
}

pub struct Exporter;

impl Exporter {
    pub fn export_search_results(
        results: &[SearchResult],
        path: &Path,
    ) -> Result<()> {
        let format = ExportFormat::from_path(path);
        
        let content = match format {
            ExportFormat::Json => serde_json::to_string_pretty(results)?,
            ExportFormat::Markdown => Self::search_results_to_markdown(results),
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    pub fn export_documentation(
        doc: &Documentation,
        path: &Path,
    ) -> Result<()> {
        let format = ExportFormat::from_path(path);
        
        let content = match format {
            ExportFormat::Json => serde_json::to_string_pretty(doc)?,
            ExportFormat::Markdown => Self::documentation_to_markdown(doc),
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    fn search_results_to_markdown(results: &[SearchResult]) -> String {
        let mut md = String::new();
        
        md.push_str("# Search Results\n\n");
        md.push_str(&format!("Found {} results\n\n", results.len()));
        
        for (idx, result) in results.iter().enumerate() {
            md.push_str(&format!("## {}. {}\n\n", idx + 1, result.title));
            md.push_str(&format!("- **Library**: {}\n", result.library));
            md.push_str(&format!("- **ID**: `{}`\n", result.id));
            
            if let Some(url) = &result.url {
                md.push_str(&format!("- **URL**: [{}]({})\n", url, url));
            }
            
            md.push_str(&format!("- **Relevance**: {:.2}\n\n", result.relevance_score));
            
            md.push_str("### Excerpt\n\n");
            md.push_str(&result.excerpt);
            md.push_str("\n\n---\n\n");
        }
        
        md
    }
    
    fn documentation_to_markdown(doc: &Documentation) -> String {
        let mut md = String::new();
        
        // Header
        md.push_str(&format!("# {} Documentation\n\n", doc.library.name));
        
        if let Some(version) = &doc.library.version {
            md.push_str(&format!("**Version**: {}\n\n", version));
        }
        
        if let Some(desc) = &doc.library.description {
            md.push_str(&format!("> {}\n\n", desc));
        }
        
        // Table of Contents
        if doc.sections.len() > 1 {
            md.push_str("## Table of Contents\n\n");
            for section in &doc.sections {
                let anchor = section.title.to_lowercase().replace(' ', "-");
                md.push_str(&format!("- [{}](#{})\n", section.title, anchor));
            }
            md.push_str("\n");
        }
        
        // Sections
        for section in &doc.sections {
            md.push_str(&format!("## {}\n\n", section.title));
            
            if let Some(url) = &section.url {
                md.push_str(&format!("*Source: [{}]({})*\n\n", url, url));
            }
            
            md.push_str(&section.content);
            md.push_str("\n\n");
            
            // Code examples
            for example in &section.code_examples {
                if let Some(desc) = &example.description {
                    md.push_str(&format!("### {}\n\n", desc));
                }
                
                md.push_str(&format!("```{}\n", example.language));
                md.push_str(&example.code);
                if !example.code.ends_with('\n') {
                    md.push('\n');
                }
                md.push_str("```\n\n");
            }
        }
        
        // Footer
        md.push_str("---\n\n");
        md.push_str("*Generated by [Manx](https://github.com/neur0map/manx) - ");
        md.push_str("Powered by Context7 MCP*\n");
        
        md
    }
    
    pub async fn export_batch_snippets(
        results: &[crate::client::SearchResult],
        path: &Path,
        json_format: bool,
        library: &str,
        cache_manager: &crate::cache::CacheManager,
    ) -> Result<()> {
        let _format = if json_format {
            ExportFormat::Json
        } else {
            ExportFormat::Markdown
        };
        
        let content = if json_format {
            Self::batch_snippets_to_json(results, library, cache_manager).await?
        } else {
            Self::batch_snippets_to_markdown(results, library, cache_manager).await?
        };
        
        fs::write(path, content)
            .with_context(|| format!("Failed to write to {:?}", path))?;
        
        Ok(())
    }
    
    async fn batch_snippets_to_markdown(
        results: &[crate::client::SearchResult],
        library: &str,
        cache_manager: &crate::cache::CacheManager,
    ) -> Result<String> {
        let mut md = String::new();
        
        md.push_str(&format!("# {} Documentation Snippets\n\n", library.to_uppercase()));
        md.push_str(&format!("Generated on: {}\n\n", 
            chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
        md.push_str("---\n\n");
        
        for result in results {
            // Get the full snippet content from cache
            let snippet_key = format!("{}_{}", library, result.id);
            if let Ok(Some(content)) = cache_manager.get::<String>("snippets", &snippet_key).await {
                md.push_str(&format!("## {}\n", result.title));
                md.push_str(&format!("**Library:** {}  \n", result.library));
                md.push_str(&format!("**ID:** {}  \n\n", result.id));
                
                // Parse and format the Context7 content
                md.push_str(&Self::format_context7_content_for_markdown(&content));
                md.push_str("\n\n---\n\n");
            }
        }
        
        md.push_str(&format!("\n*Generated by manx - A blazing-fast CLI documentation finder*  \n"));
        md.push_str(&format!("*Total snippets: {}*\n", results.len()));
        
        Ok(md)
    }
    
    async fn batch_snippets_to_json(
        results: &[crate::client::SearchResult],
        library: &str,
        cache_manager: &crate::cache::CacheManager,
    ) -> Result<String> {
        use serde_json::json;
        
        let mut snippets = Vec::new();
        
        for result in results {
            let snippet_key = format!("{}_{}", library, result.id);
            if let Ok(Some(content)) = cache_manager.get::<String>("snippets", &snippet_key).await {
                snippets.push(json!({
                    "id": result.id,
                    "title": result.title,
                    "library": result.library,
                    "content": content,
                    "relevance_score": result.relevance_score
                }));
            }
        }
        
        let output = json!({
            "library": library,
            "total_snippets": results.len(),
            "snippets": snippets,
            "generated": chrono::Utc::now().to_rfc3339()
        });
        
        Ok(serde_json::to_string_pretty(&output)?)
    }
    
    fn format_context7_content_for_markdown(content: &str) -> String {
        let mut formatted = String::new();
        let lines: Vec<&str> = content.lines().collect();
        let mut i = 0;
        
        while i < lines.len() {
            let line = lines[i];
            
            if line.starts_with("TITLE: ") {
                // Skip title as it's already in the header
                i += 1;
                continue;
            }
            
            if line.starts_with("DESCRIPTION: ") {
                formatted.push_str(&line[13..]);
                formatted.push_str("\n\n");
                i += 1;
                continue;
            }
            
            if line.starts_with("SOURCE: ") {
                formatted.push_str(&format!("**Source:** {}\n\n", &line[8..]));
                i += 1;
                continue;
            }
            
            if line.starts_with("LANGUAGE: ") {
                let language = &line[10..];
                formatted.push_str(&format!("**{}:**\n", language));
                i += 1;
                
                // Skip "CODE:" line if present
                if i < lines.len() && lines[i].starts_with("CODE:") {
                    i += 1;
                }
                
                // Look for code block
                if i < lines.len() && lines[i].starts_with("```") {
                    // Start code block with language
                    formatted.push_str("```");
                    formatted.push_str(&language.to_lowercase());
                    formatted.push('\n');
                    i += 1;
                    
                    // Copy all code content until closing ```
                    while i < lines.len() && !lines[i].starts_with("```") {
                        formatted.push_str(lines[i]);
                        formatted.push('\n');
                        i += 1;
                    }
                    
                    // Close code block
                    if i < lines.len() && lines[i].starts_with("```") {
                        formatted.push_str("```\n\n");
                        i += 1;
                    }
                } else {
                    // If no code block found, just add a newline
                    formatted.push('\n');
                }
                continue;
            }
            
            // Skip separators but preserve other content
            if line.starts_with("---") {
                i += 1;
                continue;
            }
            
            // Skip excessive empty lines but preserve structure
            if line.trim().is_empty() {
                formatted.push('\n');
                i += 1;
                continue;
            }
            
            // Regular content - preserve as-is
            formatted.push_str(line);
            formatted.push('\n');
            i += 1;
        }
        
        // Clean up excessive newlines
        while formatted.ends_with("\n\n\n") {
            formatted.pop();
        }
        
        formatted
    }
}